#include "mlir/Dialect/Arith/IR/ArithOps.td"
#include "mlir/Dialect/Func/IR/FuncOps.td"
#include "mlir/Dialect/Vector/IR/VectorOps.td"
#include "mlir/IR/BuiltinTypes.td"
#include "mlir/IR/OpBase.td"

Rewrite ConvertTranspose(op: Op<vector.transpose>, input0: Op<vector.transfer_read>, output: Op<vector.transfer_write>, outputType: TypeRange) ->(dispatch: Op<func.callOp>, invoke: Op<func.callOp>);

Constraint ValidateTranspose(op: Op<vector.transpose>, input0: Op<vector.transfer_read>, output: Op<vector.transfer_write>, outputType: TypeRange);

Rewrite ConvertBroadcast(op: Op<vector.broadcast>, input: Op<vector.transfer_read>, output: Op<vector.transfer_write>)->(dispatch: Op<func.callOp>, invoke: Op<func.callOp>);

Constraint ValidateBroadcast(op: Op<vector.broadcast>, input0: Op<vector.transfer_read>, output: Op<vector.transfer_write>);

Constraint ValidateBrgemm(op: Op<vector.contract>, input0: Op<>, input1: Op<>, input2: Op<>, output: Op<>);

Rewrite CreateBrgemmWithBetaZero(op: Op<vector.contract>, input0: Op<vector.transfer_read>, input1: Op<vector.transfer_read>, input2: Op<vector.transfer_read>, betaZero: Op<vector.transfer_write>)->(dispatch: Op<func.callOp>, invoke: Op<func.callOp>);

Rewrite CreateBrgemm(op: Op<vector.contract>, input0: Op<vector.transfer_read>, input1: Op<vector.transfer_read>, input2: Op<vector.transfer_read>)->(dispatch: Op<func.callOp>, invoke: Op<func.callOp>);

Pattern ConvertContractToBrgemmWithBetaZero {
  let input0 = op<vector.transfer_read>(alloc0: Value, indices0 : ValueRange, const0: Value, constIndex0: ValueRange) ->(output0: TypeRange);
  let input1 = op<vector.transfer_read>(alloc1: Value, indices1: ValueRange, const0, constIndex1: ValueRange)->(output1: TypeRange);
  let input2 = op<vector.transfer_read>(alloc2: Value, indices2:ValueRange, const0, constIndex2: ValueRange)->(output2: TypeRange);
  let cst = op<arith.constant>()->(constantVector : AnyVectorOfNonZeroRank);
  let betaZero = op<vector.transfer_write>(cst, alloc2, input3: ValueRange, input4: ValueRange);
  let root = op<vector.contract>(input0, input1, input2)->(output : TypeRange);
  let contractOutput = op<vector.transfer_write>(root, alloc2, outIndices: ValueRange, outBounds: ValueRange);
  ValidateBrgemm(root, input0, input1, input2, contractOutput);

  rewrite root with {
    let replacement = CreateBrgemmWithBetaZero(root, input0, input1, input2, contractOutput);
    replace root with(replacement.dispatch, replacement.invoke);
    erase contractOutput;
    erase betaZero;
  };
}

Pattern ConvertContractToBrgemm {
  let input0 = op<vector.transfer_read>(alloc0: Value, indices0: ValueRange, const0: Value, constIndex0: ValueRange)->(output0: TypeRange);
  let input1 = op<vector.transfer_read>(alloc1: Value, indices1: ValueRange, const1: Value, constIndex1: ValueRange)->(output1: TypeRange);
  let input2 = op<vector.transfer_read>(alloc2: Value, indices2: ValueRange, const2: Value, constIndex2: ValueRange)->(output2:TypeRange);
  let root = op<vector.contract>(input0, input1, input2)->(output : TypeRange);
  let rootOutput = op<vector.transfer_write>(root, alloc2, outindices: ValueRange, constIndex3: ValueRange);
  ValidateBrgemm(root, input0, input1, input2, rootOutput);
  rewrite root with {
    let replacement = CreateBrgemm(root, input0, input1, input2);
    erase rootOutput;
  };
}

Pattern ConvertTransposePattern {
  let input0 = op<vector.transfer_read>(alloc0: Value, indices0: ValueRange, const0: Value, constIndex: ValueRange)->(output : TypeRange);
  let transpose = op<vector.transpose>(input0)->(transposeOutput0 : Type);
  let output0 = op<vector.transfer_write>(transpose, alloc1 : Value, outindices : ValueRange, constIndex2 : ValueRange)->(typeRange : TypeRange);
  ValidateTranspose(transpose, input0, output0, transposeOutput0);
  rewrite transpose with {
    let replacement = ConvertTranspose(transpose, input0, output0, transposeOutput0);
    replace transpose with(replacement.dispatch, replacement.invoke);
    erase output0;
  };
}

Pattern ConvertBroadcastPattern {
  let input0 = op<vector.transfer_read>(alloc0: Value, indices0: ValueRange, const0: Value, constIndex: ValueRange)->(output: TypeRange);
  let broadcast = op<vector.broadcast>(input0)->(broadcastOutput0 : Type);
  let output0 = op<vector.transfer_write>(broadcast, alloc1: Value, outindices: ValueRange, constIndex2: ValueRange)->(typeRange: TypeRange);
  ValidateBroadcast(broadcast, input0, output0);
  rewrite broadcast with {
    let replacement = ConvertBroadcast(broadcast, input0, output0);
    replace broadcast with(replacement.dispatch, replacement.invoke);
    erase output0;
  };
}
