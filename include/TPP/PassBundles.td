//===- PassBundles.td --------------------------------------*- Tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef TPP_DIALECT_TPP_PASSBUNDLES
#define TPP_DIALECT_TPP_PASSBUNDLES

include "mlir/Pass/PassBase.td"

def DefaultPipeline : Pass<"default-pipeline", "ModuleOp"> {
  let summary = "The default compiler lowering pipeline";
  let description = [{
    A collection of passes that lower everything to MLIR LLVM IR.
  }];
  let options = [
    Option<"gpuBackend", "gpu", "std::string",
            /*default=*/"\"\"",
           "Optional target GPU backend.">,
  ];
}

def DefaultTppPasses : Pass<"default-tpp-passes", "ModuleOp"> {
  let summary = "Collection of default TPP passes";
  let description = [{
    A collection of passes that lower everything TPP-related
    to standard low-level dialects.
  }];
  let options= [
    Option<"linalgToLoops", "linalg-to-loops",
           "bool", /*default=*/"false",
           "Skip all TPP transformations. Lower linalg directly to loops.">,
    ListOption<"tileShapeM", "M-tile-shape", "unsigned",
               "Shape to reshape the M tensor into">,
    ListOption<"tileShapeN", "N-tile-shape", "unsigned",
               "Shape to reshape the N tensor into">

  ];
}

def TppMapping : Pass<"tpp-mapping", "ModuleOp"> {
  let summary = "Map operations to be TPP compatible";
  let description = [{
    Apply collection of TPP rewriting passes to map eligble operations
    into equivalent TPP-compatible forms.
  }];
  let dependentDialects = ["linalg::LinalgDialect",
                           "memref::MemRefDialect",
                           "scf::SCFDialect",
                           "tensor::TensorDialect"];
}

def LinalgLowering : Pass<"linalg-lowering", "func::FuncOp"> {
  let summary = "Lower Linalg operations to XSMM operations.";
  let dependentDialects = ["xsmm::XsmmDialect",
                           "scf::SCFDialect",
                           "memref::MemRefDialect"];
}

def LowLevelParallelization : Pass<"low-level-parallel", "ModuleOp"> {
  let summary = "Low level parallelization (multi-threading, AMX config).";
  let dependentDialects = ["affine::AffineDialect",
                           "arith::ArithDialect",
                           "func::FuncDialect",
                           "memref::MemRefDialect",
                           "scf::SCFDialect",
                           "xsmm::XsmmDialect",
                           "LLVM::LLVMDialect"];
  let options = [
    ListOption<"tileShapeM", "M-tile-shape", "unsigned",
               "Shape to reshape the M tensor into">,
    ListOption<"tileShapeN", "N-tile-shape", "unsigned",
               "Shape to reshape the N tensor into">

  ];
}

def LocalDialectsLowering : Pass<"lower-local-dialects", "ModuleOp"> {
  let summary = "Lower all local dialects (XSMM, check etc.).";
  let dependentDialects = ["affine::AffineDialect",
                           "arith::ArithDialect",
                           "func::FuncDialect",
                           "memref::MemRefDialect",
                           "check::CheckDialect",
                           "perf::PerfDialect",
                           "scf::SCFDialect",
                           "tensor::TensorDialect",
                           "xsmm::XsmmDialect",
                           "LLVM::LLVMDialect"];
}

def Postprocessing : Pass<"postprocess", "func::FuncOp"> {
  let summary = "IR postprocessing pass";
  let description = [{
    Apply various postprocessing passes such parallel loop fusion,
    buffer deallocation, general cleanup etc.
  }];
  let dependentDialects = ["bufferization::BufferizationDialect",
                           "scf::SCFDialect",
                           "memref::MemRefDialect"];
}

def Cleanup : Pass<"cleanup"> {
  let summary = "General IR cleanup e.g., canonicalization, CSE etc.";
}

def GpuPipeline : Pass<"gpu-pipeline", "ModuleOp"> {
  let summary = "Lower all eligible operations into GPU compatible IR";
  let options = [
    Option<"gpuBackend", "gpu", "std::string",
            /*default=*/"\"cuda\"",
           "Target GPU backend for lowering (cuda).">,
  ];
}

def GpuConversion : Pass<"gpu-conversion", "ModuleOp"> {
  let summary = "Convert operations to GPU";
  let description = [{
    Convert all eligble operations into generic GPU operations.
  }];
  let options = [
    Option<"useWmma", "wmma",
           "bool", /*default=*/"false",
           "Use WMMA operations">,
    ListOption<"warpTile", "warp-tile", "int64_t", "Warp tile sizes MxNxK">,
  ];
  let dependentDialects = ["linalg::LinalgDialect",
                           "scf::SCFDialect",
                           "memref::MemRefDialect",
                           "gpu::GPUDialect"];
}

def GpuToCuda : Pass<"gpu-to-cuda", "ModuleOp"> {
  let summary = "Lower generic GPU operations to CUDA backend";
  let dependentDialects = ["affine::AffineDialect",
                           "arith::ArithDialect",
                           "memref::MemRefDialect",
                           "scf::SCFDialect",
                           "gpu::GPUDialect",
                           "NVVM::NVVMDialect",
                           "nvgpu::NVGPUDialect"];
  let options = [
    Option<"gpuTriple", "triple", "std::string",
            /*default=*/"\"nvptx64-nvidia-cuda\"",
           "GPU target triple.">,
    Option<"gpuChip", "chip", "std::string",
            /*default=*/"\"sm_70\"",
           "GPU target architecture.">,
    Option<"gpuFeatures", "features", "std::string",
            /*default=*/"\"+ptx60\"",
           "GPU target features.">,
  ];
}

def GpuToVulkan : Pass<"gpu-to-vulkan", "ModuleOp"> {
  let summary = "Lower generic GPU operations to Vulkan backend";
  let dependentDialects = ["arith::ArithDialect",
                           "memref::MemRefDialect",
                           "func::FuncDialect",
                           "gpu::GPUDialect",
                           "spirv::SPIRVDialect"];
}

#endif // TPP_DIALECT_TPP_PASSBUNDLES
